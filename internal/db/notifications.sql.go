// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notifications.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUnreadNotifications = `-- name: CountUnreadNotifications :one
SELECT count(*) FROM notifications
WHERE pharmacy_id = $1::BIGINT AND read = false
`

func (q *Queries) CountUnreadNotifications(ctx context.Context, pharmacyID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUnreadNotifications, pharmacyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNotification = `-- name: CreateNotification :exec
INSERT INTO notifications (pharmacy_id, prescription_id, transition_type)
VALUES ($1, $2, $3)
ON CONFLICT (prescription_id, transition_type) DO NOTHING
`

type CreateNotificationParams struct {
	PharmacyID     int64
	PrescriptionID int64
	TransitionType string
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) error {
	_, err := q.db.Exec(ctx, createNotification, arg.PharmacyID, arg.PrescriptionID, arg.TransitionType)
	return err
}

const listNotificationsByPharmacy = `-- name: ListNotificationsByPharmacy :many
SELECT
    n.id,
    n.pharmacy_id,
    n.prescription_id,
    n.transition_type,
    n.read,
    n.created_at,
    p.medication_name,
    p.units_per_box,
    p.daily_consumption,
    p.box_start_date,
    pat.id AS patient_id,
    pat.first_name,
    pat.last_name
FROM notifications n
JOIN prescriptions p ON n.prescription_id = p.id
JOIN patients pat ON p.patient_id = pat.id
WHERE n.pharmacy_id = $1::BIGINT
ORDER BY n.created_at DESC
`

type ListNotificationsByPharmacyRow struct {
	ID               int64
	PharmacyID       int64
	PrescriptionID   int64
	TransitionType   string
	Read             bool
	CreatedAt        pgtype.Timestamptz
	MedicationName   string
	UnitsPerBox      int32
	DailyConsumption pgtype.Numeric
	BoxStartDate     pgtype.Date
	PatientID        int64
	FirstName        string
	LastName         string
}

func (q *Queries) ListNotificationsByPharmacy(ctx context.Context, pharmacyID int64) ([]ListNotificationsByPharmacyRow, error) {
	rows, err := q.db.Query(ctx, listNotificationsByPharmacy, pharmacyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNotificationsByPharmacyRow
	for rows.Next() {
		var i ListNotificationsByPharmacyRow
		if err := rows.Scan(
			&i.ID,
			&i.PharmacyID,
			&i.PrescriptionID,
			&i.TransitionType,
			&i.Read,
			&i.CreatedAt,
			&i.MedicationName,
			&i.UnitsPerBox,
			&i.DailyConsumption,
			&i.BoxStartDate,
			&i.PatientID,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAllNotificationsRead = `-- name: MarkAllNotificationsRead :exec
UPDATE notifications
SET read = true
WHERE pharmacy_id = $1::BIGINT AND read = false
`

func (q *Queries) MarkAllNotificationsRead(ctx context.Context, pharmacyID int64) error {
	_, err := q.db.Exec(ctx, markAllNotificationsRead, pharmacyID)
	return err
}

const markNotificationRead = `-- name: MarkNotificationRead :exec
UPDATE notifications
SET read = true
WHERE id = $1 AND pharmacy_id = $2::BIGINT
`

type MarkNotificationReadParams struct {
	ID         int64
	PharmacyID int64
}

func (q *Queries) MarkNotificationRead(ctx context.Context, arg MarkNotificationReadParams) error {
	_, err := q.db.Exec(ctx, markNotificationRead, arg.ID, arg.PharmacyID)
	return err
}
