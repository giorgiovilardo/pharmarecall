// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (prescription_id, cycle_start_date, estimated_depletion_date, status)
VALUES ($1, $2, $3, $4)
RETURNING id, prescription_id, cycle_start_date, estimated_depletion_date, status, created_at, updated_at
`

type CreateOrderParams struct {
	PrescriptionID         int64
	CycleStartDate         pgtype.Date
	EstimatedDepletionDate pgtype.Date
	Status                 string
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.PrescriptionID,
		arg.CycleStartDate,
		arg.EstimatedDepletionDate,
		arg.Status,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.PrescriptionID,
		&i.CycleStartDate,
		&i.EstimatedDepletionDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fulfillActiveOrderByPrescription = `-- name: FulfillActiveOrderByPrescription :exec
UPDATE orders
SET status = 'fulfilled', updated_at = now()
WHERE prescription_id = $1
  AND status IN ('pending', 'prepared')
`

func (q *Queries) FulfillActiveOrderByPrescription(ctx context.Context, prescriptionID int64) error {
	_, err := q.db.Exec(ctx, fulfillActiveOrderByPrescription, prescriptionID)
	return err
}

const getActiveOrderByPrescription = `-- name: GetActiveOrderByPrescription :one
SELECT id, prescription_id, cycle_start_date, estimated_depletion_date, status, created_at, updated_at
FROM orders
WHERE prescription_id = $1::BIGINT
  AND status IN ('pending', 'prepared')
  AND cycle_start_date = $2::DATE
LIMIT 1
`

type GetActiveOrderByPrescriptionParams struct {
	PrescriptionID int64
	CycleStartDate pgtype.Date
}

func (q *Queries) GetActiveOrderByPrescription(ctx context.Context, arg GetActiveOrderByPrescriptionParams) (Order, error) {
	row := q.db.QueryRow(ctx, getActiveOrderByPrescription, arg.PrescriptionID, arg.CycleStartDate)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.PrescriptionID,
		&i.CycleStartDate,
		&i.EstimatedDepletionDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, prescription_id, cycle_start_date, estimated_depletion_date, status, created_at, updated_at
FROM orders
WHERE id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id int64) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.PrescriptionID,
		&i.CycleStartDate,
		&i.EstimatedDepletionDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDashboardOrders = `-- name: ListDashboardOrders :many
SELECT
    o.id AS order_id,
    o.prescription_id,
    o.cycle_start_date,
    o.estimated_depletion_date,
    o.status AS order_status,
    p.medication_name,
    p.units_per_box,
    p.daily_consumption,
    p.box_start_date,
    pat.id AS patient_id,
    pat.first_name,
    pat.last_name,
    pat.fulfillment,
    pat.delivery_address,
    pat.phone,
    pat.email
FROM orders o
JOIN prescriptions p ON o.prescription_id = p.id
JOIN patients pat ON p.patient_id = pat.id
WHERE pat.pharmacy_id = $1::BIGINT
ORDER BY o.estimated_depletion_date ASC
`

type ListDashboardOrdersRow struct {
	OrderID                int64
	PrescriptionID         int64
	CycleStartDate         pgtype.Date
	EstimatedDepletionDate pgtype.Date
	OrderStatus            string
	MedicationName         string
	UnitsPerBox            int32
	DailyConsumption       pgtype.Numeric
	BoxStartDate           pgtype.Date
	PatientID              int64
	FirstName              string
	LastName               string
	Fulfillment            string
	DeliveryAddress        string
	Phone                  string
	Email                  string
}

func (q *Queries) ListDashboardOrders(ctx context.Context, pharmacyID int64) ([]ListDashboardOrdersRow, error) {
	rows, err := q.db.Query(ctx, listDashboardOrders, pharmacyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDashboardOrdersRow
	for rows.Next() {
		var i ListDashboardOrdersRow
		if err := rows.Scan(
			&i.OrderID,
			&i.PrescriptionID,
			&i.CycleStartDate,
			&i.EstimatedDepletionDate,
			&i.OrderStatus,
			&i.MedicationName,
			&i.UnitsPerBox,
			&i.DailyConsumption,
			&i.BoxStartDate,
			&i.PatientID,
			&i.FirstName,
			&i.LastName,
			&i.Fulfillment,
			&i.DeliveryAddress,
			&i.Phone,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPrescriptionsInLookahead = `-- name: ListPrescriptionsInLookahead :many
SELECT
    p.id AS prescription_id,
    p.units_per_box,
    p.daily_consumption,
    p.box_start_date,
    pat.id AS patient_id
FROM prescriptions p
JOIN patients pat ON p.patient_id = pat.id
WHERE pat.pharmacy_id = $1::BIGINT
  AND pat.consensus = true
ORDER BY p.id
`

type ListPrescriptionsInLookaheadRow struct {
	PrescriptionID   int64
	UnitsPerBox      int32
	DailyConsumption pgtype.Numeric
	BoxStartDate     pgtype.Date
	PatientID        int64
}

func (q *Queries) ListPrescriptionsInLookahead(ctx context.Context, pharmacyID int64) ([]ListPrescriptionsInLookaheadRow, error) {
	rows, err := q.db.Query(ctx, listPrescriptionsInLookahead, pharmacyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPrescriptionsInLookaheadRow
	for rows.Next() {
		var i ListPrescriptionsInLookaheadRow
		if err := rows.Scan(
			&i.PrescriptionID,
			&i.UnitsPerBox,
			&i.DailyConsumption,
			&i.BoxStartDate,
			&i.PatientID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE orders
SET status = $2, updated_at = now()
WHERE id = $1
`

type UpdateOrderStatusParams struct {
	ID     int64
	Status string
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderStatus, arg.ID, arg.Status)
	return err
}
